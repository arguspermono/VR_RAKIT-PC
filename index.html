<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <title>Babylon VR - Mobo & Processor Snap</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <style>
    html, body { width: 100%; height: 100%; margin: 0; overflow: hidden; background: #000; }
    canvas { width: 100%; height: 100%; touch-action: none; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>

  <script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);

  const createScene = async () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.8, 0.9, 1);

    const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 1.6, -3), scene);
    camera.attachControl(canvas, true);
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // === Ground ===
    const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 10, height: 10 }, scene);
    const gmat = new BABYLON.StandardMaterial("gmat", scene);
    gmat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
    ground.material = gmat;

    // === Background Lab ===
    BABYLON.SceneLoader.ImportMeshAsync("", "assets/", "computer_lab.glb", scene)
      .then(() => console.log("Background loaded"))
      .catch(() => console.warn("Background not found, skipped."));

    // === Load Motherboard ===
    const moboResult = await BABYLON.SceneLoader.ImportMeshAsync("", "assets/", "mobo.glb", scene);
    const mobo = moboResult.meshes[0];
    mobo.position = new BABYLON.Vector3(0, 0.9, 0);
    mobo.scaling = new BABYLON.Vector3(1, 1, 1);

    // === Load Processor ===
    const procResult = await BABYLON.SceneLoader.ImportMeshAsync("", "assets/", "processor.glb", scene);
    const proc = procResult.meshes[0];
    proc.position = new BABYLON.Vector3(0.5, 1.2, 0);
    proc.scaling = new BABYLON.Vector3(1, 1, 1);

    // === Snap Target ===
    const snapTarget = new BABYLON.TransformNode("snapTarget", scene);
    snapTarget.position = new BABYLON.Vector3(0, 1.02, 0); // posisi soket CPU kira-kira
    const SNAP_DISTANCE = 0.1;

    // ========== ðŸ–± MOUSE GRAB ==========
    let isMouseGrabbing = false;
    let grabDepth = 0;
    let grabOffset = new BABYLON.Vector3();

    scene.onPointerObservable.add((pointerInfo) => {
      const pick = scene.pick(scene.pointerX, scene.pointerY);
      const hoverHit = pick && pick.hit && pick.pickedMesh === proc;

      switch (pointerInfo.type) {
        case BABYLON.PointerEventTypes.POINTERMOVE:
          if (!isMouseGrabbing) {
            proc.material?.diffuseColor
              ? (proc.material.diffuseColor = hoverHit ? new BABYLON.Color3(0, 1, 0) : new BABYLON.Color3(0.2, 0.5, 1))
              : null;
          } else {
            const pickRay = scene.createPickingRay(scene.pointerX, scene.pointerY, BABYLON.Matrix.Identity(), camera);
            const targetPoint = pickRay.origin.add(pickRay.direction.scale(grabDepth));
            const newPos = targetPoint.add(grabOffset);
            proc.position.copyFrom(newPos);
          }
          break;

        case BABYLON.PointerEventTypes.POINTERDOWN:
          if (hoverHit) {
            isMouseGrabbing = true;
            const cameraToProc = proc.position.subtract(camera.position);
            grabDepth = BABYLON.Vector3.Dot(cameraToProc, camera.getForwardRay().direction);
            if (pick && pick.hit) grabOffset = proc.position.subtract(pick.pickedPoint);
            proc.material = new BABYLON.StandardMaterial("hover", scene);
            proc.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
          }
          break;

        case BABYLON.PointerEventTypes.POINTERUP:
          if (isMouseGrabbing) {
            isMouseGrabbing = false;
            proc.material.diffuseColor = new BABYLON.Color3(0.2, 0.5, 1);

            const dist = BABYLON.Vector3.Distance(proc.position, snapTarget.position);
            if (dist < SNAP_DISTANCE) {
              proc.position.copyFrom(snapTarget.position);
            }
          }
          break;
      }
    });

    // ========== ðŸ•¹ VR GRAB ==========
    const xr = await scene.createDefaultXRExperienceAsync({ floorMeshes: [ground] });

    xr.input.onControllerAddedObservable.add((controller) => {
      const grip = controller.grip || controller.pointer;
      let isGrabbing = false;
      let offset = new BABYLON.Vector3();

      controller.onMotionControllerInitObservable.add((mc) => {
        const trigger = mc.getComponent("xr-standard-trigger");
        trigger.onButtonStateChangedObservable.add((state) => {
          if (state.pressed && !isGrabbing) {
            const ray = new BABYLON.Ray(controller.pointer.position, controller.pointer.forward, 1.5);
            const pick = scene.pickWithRay(ray);
            if (pick.hit && pick.pickedMesh === proc) {
              isGrabbing = true;
              offset = proc.position.subtract(grip.getAbsolutePosition());
              proc.material = new BABYLON.StandardMaterial("hover", scene);
              proc.material.diffuseColor = new BABYLON.Color3(0, 1, 0);
            }
          } else if (!state.pressed && isGrabbing) {
            isGrabbing = false;
            proc.material.diffuseColor = new BABYLON.Color3(0.2, 0.5, 1);
            const dist = BABYLON.Vector3.Distance(proc.position, snapTarget.position);
            if (dist < SNAP_DISTANCE) proc.position.copyFrom(snapTarget.position);
          }
        });
      });

      scene.onBeforeRenderObservable.add(() => {
        if (!controller.pointer) return;
        if (isGrabbing) {
          const gripPos = grip.getAbsolutePosition().add(offset);
          proc.position.copyFrom(gripPos);
        }
      });
    });

    return scene;
  };

  createScene().then((scene) => {
    engine.runRenderLoop(() => scene.render());
  });
  window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
