<!DOCTYPE html>
<html lang="id">
<head>
  <meta charset="UTF-8" />
  <title>Babylon VR - Processor & Motherboard (Scaled)</title>
  <script src="https://cdn.babylonjs.com/babylon.js"></script>
  <script src="https://cdn.babylonjs.com/loaders/babylonjs.loaders.min.js"></script>
  <style>
    html, body { width:100%; height:100%; margin:0; overflow:hidden; background:#000; }
    canvas { width:100%; height:100%; touch-action:none; }
  </style>
</head>
<body>
  <canvas id="renderCanvas"></canvas>
  <script>
  const canvas = document.getElementById("renderCanvas");
  const engine = new BABYLON.Engine(canvas, true);

  const createScene = async () => {
    const scene = new BABYLON.Scene(engine);
    scene.clearColor = new BABYLON.Color3(0.8, 0.9, 1);
    const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(0, 1.6, -3), scene);
    camera.attachControl(canvas, true);
    new BABYLON.HemisphericLight("light", new BABYLON.Vector3(0, 1, 0), scene);

    // Lantai
    const ground = BABYLON.MeshBuilder.CreateGround("ground", { width: 10, height: 10 }, scene);
    const gmat = new BABYLON.StandardMaterial("gmat", scene);
    gmat.diffuseColor = new BABYLON.Color3(0.7, 0.7, 0.7);
    ground.material = gmat;

    // Background
    BABYLON.SceneLoader.ImportMeshAsync("", "assets/", "computer_lab.glb", scene)
      .then(() => console.log("Background loaded"))
      .catch(() => console.warn("Background not found, skipped."));

    // ==== LOAD MOBO ====
    const moboResult = await BABYLON.SceneLoader.ImportMeshAsync("", "assets/", "mobo.glb", scene);
    const mobo = moboResult.meshes[0];
    mobo.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
    mobo.position = new BABYLON.Vector3(0, 1, -1);

    // ==== LOAD PROCESSOR ====
    const procResult = await BABYLON.SceneLoader.ImportMeshAsync("", "assets/", "processor.glb", scene);
    const processor = procResult.meshes[0];
    processor.scaling = new BABYLON.Vector3(0.5, 0.5, 0.5);
    processor.position = new BABYLON.Vector3(0.5, 1.2, -1);
    processor.isPickable = true;

    // ===== Pointer Drag Behavior =====
    const drag = new BABYLON.PointerDragBehavior({ dragPlaneNormal: new BABYLON.Vector3(0, 1, 0) });
    processor.addBehavior(drag);

    drag.onDragStartObservable.add(() => {
      processor.getChildMeshes().forEach(m => {
        if (m.material) m.material.emissiveColor = new BABYLON.Color3(0, 1, 0);
      });
    });

    drag.onDragObservable.add(() => {
      // Snap check
      const dist = BABYLON.Vector3.Distance(processor.position, mobo.position);
      if (dist < 0.3) {
        mobo.getChildMeshes().forEach(m => {
          if (m.material) m.material.emissiveColor = new BABYLON.Color3(1, 0.6, 0.1);
        });
      } else {
        mobo.getChildMeshes().forEach(m => {
          if (m.material) m.material.emissiveColor = BABYLON.Color3.Black();
        });
      }
    });

    drag.onDragEndObservable.add(() => {
      const dist = BABYLON.Vector3.Distance(processor.position, mobo.position);
      if (dist < 0.3) {
        processor.position.copyFrom(mobo.position);
        processor.position.y += 0.05;
      }
      processor.getChildMeshes().forEach(m => {
        if (m.material) m.material.emissiveColor = BABYLON.Color3.Black();
      });
    });

    // Hover efek
    scene.onPointerObservable.add((pi) => {
      const pick = scene.pick(scene.pointerX, scene.pointerY);
      if (pick.hit && pick.pickedMesh && processor.getChildMeshes().includes(pick.pickedMesh))
        processor.getChildMeshes().forEach(m => m.material && (m.material.emissiveColor = new BABYLON.Color3(0, 1, 0)));
      else if (!drag.dragging)
        processor.getChildMeshes().forEach(m => m.material && (m.material.emissiveColor = BABYLON.Color3.Black()));
    }, BABYLON.PointerEventTypes.POINTERMOVE);

    // VR
    const xr = await scene.createDefaultXRExperienceAsync({ floorMeshes: [ground] });
    const rig = xr.baseExperience.camera.parent;
    if (rig) rig.scaling = new BABYLON.Vector3(10, 10, 10);

    return scene;
  };

  createScene().then(scene => engine.runRenderLoop(() => scene.render()));
  window.addEventListener("resize", () => engine.resize());
  </script>
</body>
</html>
